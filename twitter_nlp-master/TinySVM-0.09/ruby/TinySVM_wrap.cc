/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.6u-20010826-1259
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

/* Implementation : RUBY */

#define SWIGRUBY
/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#       endif
#endif
#else
#       define SWIGEXPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct swig_type_info {
  const char  *name;                 
  void *(*converter)(void *);
  const char  *str;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGEXPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGEXPORT(void *) SWIG_TypeCast(swig_type_info *, void *);
SWIGEXPORT(swig_type_info *) SWIG_TypeQuery(const char *);
#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  while (s) {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  }
  return 0;
}

/* Cast a pointer (needed for C++ inheritance */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

#endif

#ifdef __cplusplus
}
#endif



/* ruby.swg */
#include "ruby.h"

#define NUM2USHRT(n) NUM2UINT(n)
#define NUM2SHRT(n) (\
    (SHRT_MIN <= NUM2INT(n) && NUM2INT(n) <= SHRT_MAX)\
    ? (short)NUM2INT(n)\
    : (rb_raise(rb_eArgError, "integer %d out of range of `short'",\
               NUM2INT(n)), (short)0)\
)

#ifdef __cplusplus
# define VALUEFUNC(f) ((VALUE (*)(...))f)
# define VOIDFUNC(f) ((void (*)(...))f)
#else
# define VALUEFUNC(f) (f)
# define VOIDFUNC(f) (f)
#endif

/* rubydef.swg */
#ifdef __cplusplus
extern "C" {
#endif


static VALUE _mSWIG = Qnil;
static VALUE _cSWIG_Pointer = Qnil;

/* Define ruby class for C type */
SWIGRUNTIME(void)
SWIG_define_class(swig_type_info *type)
{
    VALUE klass;
    char *klass_name = ALLOCA_N(char, 4 + strlen(type->name) + 1);

    sprintf(klass_name, "TYPE%s", type->name);
    if (NIL_P(_cSWIG_Pointer)) {
	_cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
	rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
    }
    klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
}

/* Create a new pointer object */
SWIGRUNTIME(VALUE)
SWIG_NewPointerObj(void *ptr, swig_type_info *type)
{
    char *klass_name;
    VALUE klass;

    if (!ptr)
	return Qnil;

    klass_name = ALLOCA_N(char, 4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    klass = rb_const_get(_mSWIG, rb_intern(klass_name));
    return Data_Wrap_Struct(klass, 0, 0, ptr);
}

/* Get type mangle from class name */
SWIGRUNTIME(char *)
SWIG_MangleStr(VALUE obj)
{
  char *c;

  if (!rb_obj_is_kind_of(obj, _cSWIG_Pointer))
    return 0;

  c = rb_class2name(rb_class_of(obj));
  c += strlen(c);
  while (*(--c) != ':');
  /* skip ":TYPE" */
  c += 5;
  return c;
}

/* Convert a pointer value */
SWIGRUNTIME(void *)
SWIG_ConvertPtr(VALUE obj, swig_type_info *ty)
{
  char *c;
  void *ptr;
  swig_type_info *tc;

  if ((c = SWIG_MangleStr(obj)) == NULL)
    rb_raise(rb_eTypeError, "Expected %s", ty->str);	
  Data_Get_Struct(obj, void, ptr);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) rb_raise(rb_eTypeError, "Expected %s", ty->str);
    ptr = SWIG_TypeCast(tc, ptr);
  }
  return ptr;
}

/* Check convert */
SWIGRUNTIME(int)
SWIG_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c)
    return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

#ifdef __cplusplus
}
#endif

#define SWIG_init    Init_TinySVM
#define SWIG_name    "TinySVM"

static VALUE mTinySVM;



#include <tinysvm.h>
#include <ctype.h>
#include <string.h>
#define BaseExample TinySVM::BaseExample
#define Example TinySVM::Example 
#define Model TinySVM::Model
#undef VALUEFUNC
#define VALUEFUNC(f) ((VALUE (*)())f)

static VALUE cBaseExample;
static void free_BaseExample(BaseExample *);
#define Wrap_BaseExample(klass, ptr) (\
    (ptr) ? Data_Wrap_Struct(klass, 0, VOIDFUNC(free_BaseExample), ptr) : Qnil )
#define Get_BaseExample(val, ptr) {\
    if (NIL_P(val)) ptr = NULL;\
    else {\
        if (!rb_obj_is_kind_of(val, cBaseExample))\
            rb_raise(rb_eTypeError, "wrong argument type (expected BaseExample)");\
        Data_Get_Struct(val, BaseExample, ptr);\
        if (!ptr) rb_raise(rb_eRuntimeError, "This BaseExample already released");\
    }\
}

static VALUE cModel;
static void free_Model(Model *);
#define Wrap_Model(klass, ptr) (\
    (ptr) ? Data_Wrap_Struct(klass, 0, VOIDFUNC(free_Model), ptr) : Qnil )
#define Get_Model(val, ptr) {\
    if (NIL_P(val)) ptr = NULL;\
    else {\
        if (!rb_obj_is_kind_of(val, cModel))\
            rb_raise(rb_eTypeError, "wrong argument type (expected Model)");\
        Data_Get_Struct(val, Model, ptr);\
        if (!ptr) rb_raise(rb_eRuntimeError, "This Model already released");\
    }\
}

static VALUE cExample;
static void free_Example(Example *);
#define Wrap_Example(klass, ptr) (\
    (ptr) ? Data_Wrap_Struct(klass, 0, VOIDFUNC(free_Example), ptr) : Qnil )
#define Get_Example(val, ptr) {\
    if (NIL_P(val)) ptr = NULL;\
    else {\
        if (!rb_obj_is_kind_of(val, cExample))\
            rb_raise(rb_eTypeError, "wrong argument type (expected Example)");\
        Data_Get_Struct(val, Example, ptr);\
        if (!ptr) rb_raise(rb_eRuntimeError, "This Example already released");\
    }\
}

/* -------- TYPES TABLE (BEGIN) -------- */

static swig_type_info *swig_types[1];

/* -------- TYPES TABLE (END) -------- */

static VALUE
_wrap_BaseExample_add(VALUE self, VALUE varg1) {
    BaseExample *arg0 ;
    char *arg1 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    arg1 = STR2CSTR(varg1);
    result = (int )arg0->add((char const *)arg1);
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_BaseExample_set(VALUE self, VALUE varg1, VALUE varg2) {
    BaseExample *arg0 ;
    int arg1 ;
    char *arg2 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    arg1 = NUM2INT(varg1);
    arg2 = STR2CSTR(varg2);
    result = (int )arg0->set(arg1,(char const *)arg2);
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_BaseExample_get(VALUE self, VALUE varg1) {
    BaseExample *arg0 ;
    int arg1 ;
    char *result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    arg1 = NUM2INT(varg1);
    result = (char *)arg0->get(arg1);
    vresult = rb_str_new2(result);
    return vresult;
}


static VALUE
_wrap_BaseExample_remove(VALUE self, VALUE varg1) {
    BaseExample *arg0 ;
    int arg1 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    arg1 = NUM2INT(varg1);
    result = (int )arg0->remove(arg1);
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_BaseExample_clear(VALUE self) {
    BaseExample *arg0 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    result = (int )arg0->clear();
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_BaseExample_size(VALUE self) {
    BaseExample *arg0 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    result = (int )arg0->size();
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_BaseExample_read(int argc, VALUE *argv, VALUE self) {
    VALUE varg1 ;
    VALUE varg2 ;
    VALUE varg3 ;
    BaseExample *arg0 ;
    char *arg1 ;
    char *arg2 = "r" ;
    int arg3 = 0 ;
    int result ;
    VALUE vresult = Qnil;
    
    rb_scan_args(argc, argv, "12", &varg1, &varg2, &varg3);
    Get_BaseExample(self, arg0);
    arg1 = STR2CSTR(varg1);
    if (argc > 1) {
        arg2 = STR2CSTR(varg2);
    }
    if (argc > 2) {
        arg3 = NUM2INT(varg3);
    }
    result = (int )arg0->read((char const *)arg1,(char const *)arg2,arg3);
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_BaseExample_write(int argc, VALUE *argv, VALUE self) {
    VALUE varg1 ;
    VALUE varg2 ;
    VALUE varg3 ;
    BaseExample *arg0 ;
    char *arg1 ;
    char *arg2 = "w" ;
    int arg3 = 0 ;
    int result ;
    VALUE vresult = Qnil;
    
    rb_scan_args(argc, argv, "12", &varg1, &varg2, &varg3);
    Get_BaseExample(self, arg0);
    arg1 = STR2CSTR(varg1);
    if (argc > 1) {
        arg2 = STR2CSTR(varg2);
    }
    if (argc > 2) {
        arg3 = NUM2INT(varg3);
    }
    result = (int )arg0->write((char const *)arg1,(char const *)arg2,arg3);
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_BaseExample_readSVindex(int argc, VALUE *argv, VALUE self) {
    VALUE varg1 ;
    VALUE varg2 ;
    VALUE varg3 ;
    BaseExample *arg0 ;
    char *arg1 ;
    char *arg2 = "r" ;
    int arg3 = 0 ;
    int result ;
    VALUE vresult = Qnil;
    
    rb_scan_args(argc, argv, "12", &varg1, &varg2, &varg3);
    Get_BaseExample(self, arg0);
    arg1 = STR2CSTR(varg1);
    if (argc > 1) {
        arg2 = STR2CSTR(varg2);
    }
    if (argc > 2) {
        arg3 = NUM2INT(varg3);
    }
    result = (int )arg0->readSVindex((char const *)arg1,(char const *)arg2,arg3);
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_BaseExample_writeSVindex(int argc, VALUE *argv, VALUE self) {
    VALUE varg1 ;
    VALUE varg2 ;
    VALUE varg3 ;
    BaseExample *arg0 ;
    char *arg1 ;
    char *arg2 = "w" ;
    int arg3 = 0 ;
    int result ;
    VALUE vresult = Qnil;
    
    rb_scan_args(argc, argv, "12", &varg1, &varg2, &varg3);
    Get_BaseExample(self, arg0);
    arg1 = STR2CSTR(varg1);
    if (argc > 1) {
        arg2 = STR2CSTR(varg2);
    }
    if (argc > 2) {
        arg3 = NUM2INT(varg3);
    }
    result = (int )arg0->writeSVindex((char const *)arg1,(char const *)arg2,arg3);
    vresult = INT2NUM(result);
    return vresult;
}


static void
free_BaseExample(BaseExample *arg0) {
    delete arg0;
}
int  BaseExample_append(BaseExample *self,char *f) {
    {
        return self->write(f,"a"); 
    }
}


static VALUE
_wrap_BaseExample_append(VALUE self, VALUE varg1) {
    BaseExample *arg0 ;
    char *arg1 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    arg1 = STR2CSTR(varg1);
    result = (int )BaseExample_append(arg0,arg1);
    vresult = INT2NUM(result);
    return vresult;
}


int  BaseExample_appendSVindex(BaseExample *self,char *f) {
    {
        return self->writeSVindex(f,"a"); 
    }
}


static VALUE
_wrap_BaseExample_appendSVindex(VALUE self, VALUE varg1) {
    BaseExample *arg0 ;
    char *arg1 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    arg1 = STR2CSTR(varg1);
    result = (int )BaseExample_appendSVindex(arg0,arg1);
    vresult = INT2NUM(result);
    return vresult;
}


int  BaseExample_getDimension(BaseExample *self) {
    {
        return self->d; 
    }
}


static VALUE
_wrap_BaseExample_getDimension(VALUE self) {
    BaseExample *arg0 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    result = (int )BaseExample_getDimension(arg0);
    vresult = INT2NUM(result);
    return vresult;
}


int  BaseExample_getNonzeroDimension(BaseExample *self) {
    {
        return self->pack_d; 
    }
}


static VALUE
_wrap_BaseExample_getNonzeroDimension(VALUE self) {
    BaseExample *arg0 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    result = (int )BaseExample_getNonzeroDimension(arg0);
    vresult = INT2NUM(result);
    return vresult;
}


double  BaseExample_getY(BaseExample *self,int i) {
    {
        if (i >= 0 && i < self->l) return self->y[i];
        fprintf(stderr, "BaseExample::getY() -- index is out of range\n");
        return 0.0;
    }
}


static VALUE
_wrap_BaseExample_getY(VALUE self, VALUE varg1) {
    BaseExample *arg0 ;
    int arg1 ;
    double result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    arg1 = NUM2INT(varg1);
    result = (double )BaseExample_getY(arg0,arg1);
    vresult = rb_float_new(result);
    return vresult;
}


char const * BaseExample_getX(BaseExample *self,int i) {
    {
        const char *s = self->get(i);
        if (!s) return 0;
        
        int len = strlen (s);
        int i;
        for (i = 0; i < len;) {
            while (isspace (s[i])) i++;
            while (i < len && !isspace (s[i])) i++;
            while (i < len && isspace (s[i]))  i++;
            break;
        }
        
        return (const char*)(s + i);
    }
}


static VALUE
_wrap_BaseExample_getX(VALUE self, VALUE varg1) {
    BaseExample *arg0 ;
    int arg1 ;
    char *result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    arg1 = NUM2INT(varg1);
    result = (char *)BaseExample_getX(arg0,arg1);
    vresult = rb_str_new2(result);
    return vresult;
}


double  BaseExample_getAlpha(BaseExample *self,int i) {
    {
        if (self->alpha && i >= 0 && i < self->svindex_size) return self->alpha[i];
        fprintf(stderr, "BaseExample::getAlpha() -- \nalpha is not available or index is out of range\n");
        return 0.0;
    }
}


static VALUE
_wrap_BaseExample_getAlpha(VALUE self, VALUE varg1) {
    BaseExample *arg0 ;
    int arg1 ;
    double result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    arg1 = NUM2INT(varg1);
    result = (double )BaseExample_getAlpha(arg0,arg1);
    vresult = rb_float_new(result);
    return vresult;
}


double  BaseExample_getGradient(BaseExample *self,int i) {
    {
        if (self->G && i >= 0 && i < self->svindex_size) return self->G[i];
        fprintf(stderr, "BaseExample::getGradient() -- \ngradient is not available or index is out of range\n");
        return 0.0;
    }
}


static VALUE
_wrap_BaseExample_getGradient(VALUE self, VALUE varg1) {
    BaseExample *arg0 ;
    int arg1 ;
    double result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    arg1 = NUM2INT(varg1);
    result = (double )BaseExample_getGradient(arg0,arg1);
    vresult = rb_float_new(result);
    return vresult;
}


double  BaseExample_getG(BaseExample *self,int i) {
    {
        if (self->G && i >= 0 && i < self->svindex_size) return self->G[i];
        fprintf(stderr, "BaseExample::getG() -- index is out of range\n");
        return 0.0;
    }
}


static VALUE
_wrap_BaseExample_getG(VALUE self, VALUE varg1) {
    BaseExample *arg0 ;
    int arg1 ;
    double result ;
    VALUE vresult = Qnil;
    
    Get_BaseExample(self, arg0);
    arg1 = NUM2INT(varg1);
    result = (double )BaseExample_getG(arg0,arg1);
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Model_read(int argc, VALUE *argv, VALUE self) {
    VALUE varg1 ;
    VALUE varg2 ;
    VALUE varg3 ;
    Model *arg0 ;
    char *arg1 ;
    char *arg2 = "r" ;
    int arg3 = 0 ;
    int result ;
    VALUE vresult = Qnil;
    
    rb_scan_args(argc, argv, "12", &varg1, &varg2, &varg3);
    Get_Model(self, arg0);
    arg1 = STR2CSTR(varg1);
    if (argc > 1) {
        arg2 = STR2CSTR(varg2);
    }
    if (argc > 2) {
        arg3 = NUM2INT(varg3);
    }
    result = (int )arg0->read((char const *)arg1,(char const *)arg2,arg3);
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Model_write(int argc, VALUE *argv, VALUE self) {
    VALUE varg1 ;
    VALUE varg2 ;
    VALUE varg3 ;
    Model *arg0 ;
    char *arg1 ;
    char *arg2 = "w" ;
    int arg3 = 0 ;
    int result ;
    VALUE vresult = Qnil;
    
    rb_scan_args(argc, argv, "12", &varg1, &varg2, &varg3);
    Get_Model(self, arg0);
    arg1 = STR2CSTR(varg1);
    if (argc > 1) {
        arg2 = STR2CSTR(varg2);
    }
    if (argc > 2) {
        arg3 = NUM2INT(varg3);
    }
    result = (int )arg0->write((char const *)arg1,(char const *)arg2,arg3);
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Model_clear(VALUE self) {
    Model *arg0 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_Model(self, arg0);
    result = (int )arg0->clear();
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Model_classify(VALUE self, VALUE varg1) {
    Model *arg0 ;
    char *arg1 ;
    double result ;
    VALUE vresult = Qnil;
    
    Get_Model(self, arg0);
    arg1 = STR2CSTR(varg1);
    result = (double )arg0->classify((char const *)arg1);
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Model_estimateMargin(VALUE self) {
    Model *arg0 ;
    double result ;
    VALUE vresult = Qnil;
    
    Get_Model(self, arg0);
    result = (double )arg0->estimateMargin();
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Model_estimateSphere(VALUE self) {
    Model *arg0 ;
    double result ;
    VALUE vresult = Qnil;
    
    Get_Model(self, arg0);
    result = (double )arg0->estimateSphere();
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Model_estimateVC(VALUE self) {
    Model *arg0 ;
    double result ;
    VALUE vresult = Qnil;
    
    Get_Model(self, arg0);
    result = (double )arg0->estimateVC();
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Model_estimateXA(int argc, VALUE *argv, VALUE self) {
    VALUE varg1 ;
    Model *arg0 ;
    double arg1 = 2.0 ;
    double result ;
    VALUE vresult = Qnil;
    
    rb_scan_args(argc, argv, "01", &varg1);
    Get_Model(self, arg0);
    if (argc > 0) {
        arg1 = NUM2DBL(varg1);
    }
    result = (double )arg0->estimateXA(arg1);
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Model_compress(VALUE self) {
    Model *arg0 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_Model(self, arg0);
    result = (int )arg0->compress();
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Model_getSVnum(VALUE self) {
    Model *arg0 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_Model(self, arg0);
    result = (int )arg0->getSVnum();
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Model_getBSVnum(VALUE self) {
    Model *arg0 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_Model(self, arg0);
    result = (int )arg0->getBSVnum();
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Model_getTrainingDataSize(VALUE self) {
    Model *arg0 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_Model(self, arg0);
    result = (int )arg0->getTrainingDataSize();
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Model_getLoss(VALUE self) {
    Model *arg0 ;
    double result ;
    VALUE vresult = Qnil;
    
    Get_Model(self, arg0);
    result = (double )arg0->getLoss();
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_new_Model(VALUE self) {
    Model *result ;
    VALUE vresult = Qnil;
    
    result = (Model *)new Model();
    vresult = Wrap_Model(self, result);
    return vresult;
}


static void
free_Model(Model *arg0) {
    delete arg0;
}
static VALUE
_wrap_Example_read(int argc, VALUE *argv, VALUE self) {
    VALUE varg1 ;
    VALUE varg2 ;
    VALUE varg3 ;
    Example *arg0 ;
    char *arg1 ;
    char *arg2 = "r" ;
    int arg3 = 0 ;
    int result ;
    VALUE vresult = Qnil;
    
    rb_scan_args(argc, argv, "12", &varg1, &varg2, &varg3);
    Get_Example(self, arg0);
    arg1 = STR2CSTR(varg1);
    if (argc > 1) {
        arg2 = STR2CSTR(varg2);
    }
    if (argc > 2) {
        arg3 = NUM2INT(varg3);
    }
    result = (int )arg0->read((char const *)arg1,(char const *)arg2,arg3);
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Example_write(int argc, VALUE *argv, VALUE self) {
    VALUE varg1 ;
    VALUE varg2 ;
    VALUE varg3 ;
    Example *arg0 ;
    char *arg1 ;
    char *arg2 = "w" ;
    int arg3 = 0 ;
    int result ;
    VALUE vresult = Qnil;
    
    rb_scan_args(argc, argv, "12", &varg1, &varg2, &varg3);
    Get_Example(self, arg0);
    arg1 = STR2CSTR(varg1);
    if (argc > 1) {
        arg2 = STR2CSTR(varg2);
    }
    if (argc > 2) {
        arg3 = NUM2INT(varg3);
    }
    result = (int )arg0->write((char const *)arg1,(char const *)arg2,arg3);
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Example_rebuildSVindex(VALUE self, VALUE varg1) {
    Example *arg0 ;
    Model *arg1 ;
    int result ;
    VALUE vresult = Qnil;
    
    Get_Example(self, arg0);
    Get_Model(varg1, arg1);
    result = (int )arg0->rebuildSVindex(arg1);
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Example_learn(int argc, VALUE *argv, VALUE self) {
    VALUE varg1 ;
    Example *arg0 ;
    char *arg1 = 0 ;
    Model *result ;
    VALUE vresult = Qnil;
    
    rb_scan_args(argc, argv, "01", &varg1);
    Get_Example(self, arg0);
    if (argc > 0) {
        arg1 = STR2CSTR(varg1);
    }
    result = (Model *)arg0->learn((char const *)arg1);
    vresult = Wrap_Model(cModel, result);
    return vresult;
}


static VALUE
_wrap_new_Example(VALUE self) {
    Example *result ;
    VALUE vresult = Qnil;
    
    result = (Example *)new Example();
    vresult = Wrap_Example(self, result);
    return vresult;
}


static void
free_Example(Example *arg0) {
    delete arg0;
}

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */


static swig_type_info *swig_types_initial[] = {
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */


#ifdef __cplusplus
extern "C"
#endif
void Init_TinySVM(void) {
    int i;
    
    mTinySVM = rb_define_module("TinySVM");
    _mSWIG = rb_define_module_under(mTinySVM, "SWIG");
    
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        SWIG_define_class(swig_types[i]);
    }
    
    
    cBaseExample = rb_define_class_under(mTinySVM, "BaseExample", rb_cObject);
    rb_undef_method(CLASS_OF(cBaseExample), "new");
    rb_define_method(cBaseExample, "add", VALUEFUNC(_wrap_BaseExample_add), 1);
    rb_define_method(cBaseExample, "set", VALUEFUNC(_wrap_BaseExample_set), 2);
    rb_define_method(cBaseExample, "get", VALUEFUNC(_wrap_BaseExample_get), 1);
    rb_define_method(cBaseExample, "remove", VALUEFUNC(_wrap_BaseExample_remove), 1);
    rb_define_method(cBaseExample, "clear", VALUEFUNC(_wrap_BaseExample_clear), 0);
    rb_define_method(cBaseExample, "size", VALUEFUNC(_wrap_BaseExample_size), 0);
    rb_define_method(cBaseExample, "read", VALUEFUNC(_wrap_BaseExample_read), -1);
    rb_define_method(cBaseExample, "write", VALUEFUNC(_wrap_BaseExample_write), -1);
    rb_define_method(cBaseExample, "readSVindex", VALUEFUNC(_wrap_BaseExample_readSVindex), -1);
    rb_define_method(cBaseExample, "writeSVindex", VALUEFUNC(_wrap_BaseExample_writeSVindex), -1);
    rb_define_method(cBaseExample, "append", VALUEFUNC(_wrap_BaseExample_append), 1);
    rb_define_method(cBaseExample, "appendSVindex", VALUEFUNC(_wrap_BaseExample_appendSVindex), 1);
    rb_define_method(cBaseExample, "getDimension", VALUEFUNC(_wrap_BaseExample_getDimension), 0);
    rb_define_method(cBaseExample, "getNonzeroDimension", VALUEFUNC(_wrap_BaseExample_getNonzeroDimension), 0);
    rb_define_method(cBaseExample, "getY", VALUEFUNC(_wrap_BaseExample_getY), 1);
    rb_define_method(cBaseExample, "getX", VALUEFUNC(_wrap_BaseExample_getX), 1);
    rb_define_method(cBaseExample, "getAlpha", VALUEFUNC(_wrap_BaseExample_getAlpha), 1);
    rb_define_method(cBaseExample, "getGradient", VALUEFUNC(_wrap_BaseExample_getGradient), 1);
    rb_define_method(cBaseExample, "getG", VALUEFUNC(_wrap_BaseExample_getG), 1);
    
    cModel = rb_define_class_under(mTinySVM, "Model", cBaseExample);
    rb_define_singleton_method(cModel, "new", VALUEFUNC(_wrap_new_Model), 0);
    rb_define_method(cModel, "read", VALUEFUNC(_wrap_Model_read), -1);
    rb_define_method(cModel, "write", VALUEFUNC(_wrap_Model_write), -1);
    rb_define_method(cModel, "clear", VALUEFUNC(_wrap_Model_clear), 0);
    rb_define_method(cModel, "classify", VALUEFUNC(_wrap_Model_classify), 1);
    rb_define_method(cModel, "estimateMargin", VALUEFUNC(_wrap_Model_estimateMargin), 0);
    rb_define_method(cModel, "estimateSphere", VALUEFUNC(_wrap_Model_estimateSphere), 0);
    rb_define_method(cModel, "estimateVC", VALUEFUNC(_wrap_Model_estimateVC), 0);
    rb_define_method(cModel, "estimateXA", VALUEFUNC(_wrap_Model_estimateXA), -1);
    rb_define_method(cModel, "compress", VALUEFUNC(_wrap_Model_compress), 0);
    rb_define_method(cModel, "getSVnum", VALUEFUNC(_wrap_Model_getSVnum), 0);
    rb_define_method(cModel, "getBSVnum", VALUEFUNC(_wrap_Model_getBSVnum), 0);
    rb_define_method(cModel, "getTrainingDataSize", VALUEFUNC(_wrap_Model_getTrainingDataSize), 0);
    rb_define_method(cModel, "getLoss", VALUEFUNC(_wrap_Model_getLoss), 0);
    
    cExample = rb_define_class_under(mTinySVM, "Example", cBaseExample);
    rb_define_singleton_method(cExample, "new", VALUEFUNC(_wrap_new_Example), 0);
    rb_define_method(cExample, "read", VALUEFUNC(_wrap_Example_read), -1);
    rb_define_method(cExample, "write", VALUEFUNC(_wrap_Example_write), -1);
    rb_define_method(cExample, "rebuildSVindex", VALUEFUNC(_wrap_Example_rebuildSVindex), 1);
    rb_define_method(cExample, "learn", VALUEFUNC(_wrap_Example_learn), -1);
}

